// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

type codeRecorder struct {
	http.ResponseWriter
	status int
}

func (c *codeRecorder) WriteHeader(status int) {
	c.status = status
	c.ResponseWriter.WriteHeader(status)
}

// handleAccountEvmAddressGetRequest handles GET /account/{evm_address} operation.
//
// Get an account.
//
// GET /account/{evm_address}
func (s *Server) handleAccountEvmAddressGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/account/{evm_address}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AccountEvmAddressGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AccountEvmAddressGetOperation,
			ID:   "",
		}
	)
	params, err := decodeAccountEvmAddressGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Account
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AccountEvmAddressGetOperation,
			OperationSummary: "Get an account",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "evm_address",
					In:   "path",
				}: params.EvmAddress,
				{
					Name: "filter_book_nft_in",
					In:   "query",
				}: params.FilterBookNftIn,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AccountEvmAddressGetParams
			Response = *Account
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAccountEvmAddressGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AccountEvmAddressGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AccountEvmAddressGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeAccountEvmAddressGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAccountEvmAddressStakingEventsEventTypeGetRequest handles GET /account/{evm_address}/staking-events/{event_type} operation.
//
// Get staking events for an account.
//
// GET /account/{evm_address}/staking-events/{event_type}
func (s *Server) handleAccountEvmAddressStakingEventsEventTypeGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/account/{evm_address}/staking-events/{event_type}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AccountEvmAddressStakingEventsEventTypeGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AccountEvmAddressStakingEventsEventTypeGetOperation,
			ID:   "",
		}
	)
	params, err := decodeAccountEvmAddressStakingEventsEventTypeGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvmAddressStakingEventsEventTypeGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AccountEvmAddressStakingEventsEventTypeGetOperation,
			OperationSummary: "Get staking events for an account",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "evm_address",
					In:   "path",
				}: params.EvmAddress,
				{
					Name: "event_type",
					In:   "path",
				}: params.EventType,
				{
					Name: "pagination.key",
					In:   "query",
				}: params.PaginationKey,
				{
					Name: "pagination.limit",
					In:   "query",
				}: params.PaginationLimit,
				{
					Name: "reverse",
					In:   "query",
				}: params.Reverse,
				{
					Name: "filter_datetime_from",
					In:   "query",
				}: params.FilterDatetimeFrom,
				{
					Name: "filter_datetime_to",
					In:   "query",
				}: params.FilterDatetimeTo,
				{
					Name: "filter_book_nft_in",
					In:   "query",
				}: params.FilterBookNftIn,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AccountEvmAddressStakingEventsEventTypeGetParams
			Response = *AccountEvmAddressStakingEventsEventTypeGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAccountEvmAddressStakingEventsEventTypeGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AccountEvmAddressStakingEventsEventTypeGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AccountEvmAddressStakingEventsEventTypeGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeAccountEvmAddressStakingEventsEventTypeGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAccountEvmAddressStakingsGetRequest handles GET /account/{evm_address}/stakings operation.
//
// Get staking information for an account.
//
// GET /account/{evm_address}/stakings
func (s *Server) handleAccountEvmAddressStakingsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/account/{evm_address}/stakings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AccountEvmAddressStakingsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AccountEvmAddressStakingsGetOperation,
			ID:   "",
		}
	)
	params, err := decodeAccountEvmAddressStakingsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountEvmAddressStakingsGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AccountEvmAddressStakingsGetOperation,
			OperationSummary: "Get staking information for an account",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "evm_address",
					In:   "path",
				}: params.EvmAddress,
				{
					Name: "pagination.key",
					In:   "query",
				}: params.PaginationKey,
				{
					Name: "pagination.limit",
					In:   "query",
				}: params.PaginationLimit,
				{
					Name: "reverse",
					In:   "query",
				}: params.Reverse,
				{
					Name: "filter_book_nft_in",
					In:   "query",
				}: params.FilterBookNftIn,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AccountEvmAddressStakingsGetParams
			Response = *AccountEvmAddressStakingsGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAccountEvmAddressStakingsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AccountEvmAddressStakingsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AccountEvmAddressStakingsGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeAccountEvmAddressStakingsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAccountsGetRequest handles GET /accounts operation.
//
// Get accounts.
//
// GET /accounts
func (s *Server) handleAccountsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/accounts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AccountsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AccountsGetOperation,
			ID:   "",
		}
	)
	params, err := decodeAccountsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AccountsGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AccountsGetOperation,
			OperationSummary: "Get accounts",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "pagination.key",
					In:   "query",
				}: params.PaginationKey,
				{
					Name: "pagination.limit",
					In:   "query",
				}: params.PaginationLimit,
				{
					Name: "reverse",
					In:   "query",
				}: params.Reverse,
				{
					Name: "filter_account_in",
					In:   "query",
				}: params.FilterAccountIn,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AccountsGetParams
			Response = *AccountsGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAccountsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AccountsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AccountsGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeAccountsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBookNftEvmAddressGetRequest handles GET /book-nft/{evm_address} operation.
//
// Get a book NFT.
//
// GET /book-nft/{evm_address}
func (s *Server) handleBookNftEvmAddressGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/book-nft/{evm_address}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BookNftEvmAddressGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BookNftEvmAddressGetOperation,
			ID:   "",
		}
	)
	params, err := decodeBookNftEvmAddressGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BookNFT
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BookNftEvmAddressGetOperation,
			OperationSummary: "Get a book NFT",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "evm_address",
					In:   "path",
				}: params.EvmAddress,
				{
					Name: "filter_account_in",
					In:   "query",
				}: params.FilterAccountIn,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BookNftEvmAddressGetParams
			Response = *BookNFT
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBookNftEvmAddressGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BookNftEvmAddressGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BookNftEvmAddressGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeBookNftEvmAddressGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBookNftEvmAddressStakingEventsEventTypeGetRequest handles GET /book-nft/{evm_address}/staking-events/{event_type} operation.
//
// Get staking events for a book NFT.
//
// GET /book-nft/{evm_address}/staking-events/{event_type}
func (s *Server) handleBookNftEvmAddressStakingEventsEventTypeGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/book-nft/{evm_address}/staking-events/{event_type}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BookNftEvmAddressStakingEventsEventTypeGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BookNftEvmAddressStakingEventsEventTypeGetOperation,
			ID:   "",
		}
	)
	params, err := decodeBookNftEvmAddressStakingEventsEventTypeGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BookNftEvmAddressStakingEventsEventTypeGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BookNftEvmAddressStakingEventsEventTypeGetOperation,
			OperationSummary: "Get staking events for a book NFT",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "evm_address",
					In:   "path",
				}: params.EvmAddress,
				{
					Name: "event_type",
					In:   "path",
				}: params.EventType,
				{
					Name: "pagination.key",
					In:   "query",
				}: params.PaginationKey,
				{
					Name: "pagination.limit",
					In:   "query",
				}: params.PaginationLimit,
				{
					Name: "reverse",
					In:   "query",
				}: params.Reverse,
				{
					Name: "filter_datetime_from",
					In:   "query",
				}: params.FilterDatetimeFrom,
				{
					Name: "filter_datetime_to",
					In:   "query",
				}: params.FilterDatetimeTo,
				{
					Name: "filter_account_in",
					In:   "query",
				}: params.FilterAccountIn,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BookNftEvmAddressStakingEventsEventTypeGetParams
			Response = *BookNftEvmAddressStakingEventsEventTypeGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBookNftEvmAddressStakingEventsEventTypeGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BookNftEvmAddressStakingEventsEventTypeGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BookNftEvmAddressStakingEventsEventTypeGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeBookNftEvmAddressStakingEventsEventTypeGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBookNftEvmAddressStakingsGetRequest handles GET /book-nft/{evm_address}/stakings operation.
//
// Get staking information for a book NFT.
//
// GET /book-nft/{evm_address}/stakings
func (s *Server) handleBookNftEvmAddressStakingsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/book-nft/{evm_address}/stakings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BookNftEvmAddressStakingsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BookNftEvmAddressStakingsGetOperation,
			ID:   "",
		}
	)
	params, err := decodeBookNftEvmAddressStakingsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BookNftEvmAddressStakingsGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BookNftEvmAddressStakingsGetOperation,
			OperationSummary: "Get staking information for a book NFT",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "evm_address",
					In:   "path",
				}: params.EvmAddress,
				{
					Name: "pagination.key",
					In:   "query",
				}: params.PaginationKey,
				{
					Name: "pagination.limit",
					In:   "query",
				}: params.PaginationLimit,
				{
					Name: "reverse",
					In:   "query",
				}: params.Reverse,
				{
					Name: "filter_account_in",
					In:   "query",
				}: params.FilterAccountIn,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BookNftEvmAddressStakingsGetParams
			Response = *BookNftEvmAddressStakingsGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBookNftEvmAddressStakingsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BookNftEvmAddressStakingsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BookNftEvmAddressStakingsGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeBookNftEvmAddressStakingsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBookNftsGetRequest handles GET /book-nfts operation.
//
// Get book NFTs.
//
// GET /book-nfts
func (s *Server) handleBookNftsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/book-nfts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BookNftsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BookNftsGetOperation,
			ID:   "",
		}
	)
	params, err := decodeBookNftsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BookNftsGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BookNftsGetOperation,
			OperationSummary: "Get book NFTs",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "pagination.key",
					In:   "query",
				}: params.PaginationKey,
				{
					Name: "pagination.limit",
					In:   "query",
				}: params.PaginationLimit,
				{
					Name: "reverse",
					In:   "query",
				}: params.Reverse,
				{
					Name: "filter_book_nft_in",
					In:   "query",
				}: params.FilterBookNftIn,
				{
					Name: "filter_account_in",
					In:   "query",
				}: params.FilterAccountIn,
				{
					Name: "sort_by",
					In:   "query",
				}: params.SortBy,
				{
					Name: "sort_order",
					In:   "query",
				}: params.SortOrder,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BookNftsGetParams
			Response = *BookNftsGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBookNftsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BookNftsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BookNftsGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeBookNftsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBookNftsTimeFrameDeltaGetRequest handles GET /book-nfts/{time_frame}/delta operation.
//
// Get book NFTs.
//
// GET /book-nfts/{time_frame}/delta
func (s *Server) handleBookNftsTimeFrameDeltaGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/book-nfts/{time_frame}/delta"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BookNftsTimeFrameDeltaGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BookNftsTimeFrameDeltaGetOperation,
			ID:   "",
		}
	)
	params, err := decodeBookNftsTimeFrameDeltaGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BookNftsTimeFrameDeltaGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BookNftsTimeFrameDeltaGetOperation,
			OperationSummary: "Get book NFTs",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "time_frame",
					In:   "path",
				}: params.TimeFrame,
				{
					Name: "sort_by",
					In:   "query",
				}: params.SortBy,
				{
					Name: "sort_order",
					In:   "query",
				}: params.SortOrder,
				{
					Name: "pagination.limit",
					In:   "query",
				}: params.PaginationLimit,
				{
					Name: "pagination.page",
					In:   "query",
				}: params.PaginationPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BookNftsTimeFrameDeltaGetParams
			Response = *BookNftsTimeFrameDeltaGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBookNftsTimeFrameDeltaGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BookNftsTimeFrameDeltaGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BookNftsTimeFrameDeltaGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeBookNftsTimeFrameDeltaGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEventsAddressGetRequest handles GET /events/{address} operation.
//
// Query events.
//
// GET /events/{address}
func (s *Server) handleEventsAddressGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/events/{address}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EventsAddressGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EventsAddressGetOperation,
			ID:   "",
		}
	)
	params, err := decodeEventsAddressGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EventsAddressGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EventsAddressGetOperation,
			OperationSummary: "Query events",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "address",
					In:   "path",
				}: params.Address,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "sort_by",
					In:   "query",
				}: params.SortBy,
				{
					Name: "sort_order",
					In:   "query",
				}: params.SortOrder,
				{
					Name: "filter_block_timestamp",
					In:   "query",
				}: params.FilterBlockTimestamp,
				{
					Name: "filter_block_timestamp_gte",
					In:   "query",
				}: params.FilterBlockTimestampGte,
				{
					Name: "filter_block_timestamp_gt",
					In:   "query",
				}: params.FilterBlockTimestampGt,
				{
					Name: "filter_block_timestamp_lte",
					In:   "query",
				}: params.FilterBlockTimestampLte,
				{
					Name: "filter_block_timestamp_lt",
					In:   "query",
				}: params.FilterBlockTimestampLt,
				{
					Name: "filter_topic_1",
					In:   "query",
				}: params.FilterTopic1,
				{
					Name: "filter_topic_2",
					In:   "query",
				}: params.FilterTopic2,
				{
					Name: "filter_topic_3",
					In:   "query",
				}: params.FilterTopic3,
				{
					Name: "filter_topic_0",
					In:   "query",
				}: params.FilterTopic0,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EventsAddressGetParams
			Response = *EventsAddressGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEventsAddressGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EventsAddressGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EventsAddressGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeEventsAddressGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEventsAddressSignatureGetRequest handles GET /events/{address}/{signature} operation.
//
// Query events.
//
// GET /events/{address}/{signature}
func (s *Server) handleEventsAddressSignatureGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/events/{address}/{signature}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EventsAddressSignatureGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EventsAddressSignatureGetOperation,
			ID:   "",
		}
	)
	params, err := decodeEventsAddressSignatureGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EventsAddressSignatureGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EventsAddressSignatureGetOperation,
			OperationSummary: "Query events",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "address",
					In:   "path",
				}: params.Address,
				{
					Name: "signature",
					In:   "path",
				}: params.Signature,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "sort_by",
					In:   "query",
				}: params.SortBy,
				{
					Name: "sort_order",
					In:   "query",
				}: params.SortOrder,
				{
					Name: "filter_block_timestamp",
					In:   "query",
				}: params.FilterBlockTimestamp,
				{
					Name: "filter_block_timestamp_gte",
					In:   "query",
				}: params.FilterBlockTimestampGte,
				{
					Name: "filter_block_timestamp_gt",
					In:   "query",
				}: params.FilterBlockTimestampGt,
				{
					Name: "filter_block_timestamp_lte",
					In:   "query",
				}: params.FilterBlockTimestampLte,
				{
					Name: "filter_block_timestamp_lt",
					In:   "query",
				}: params.FilterBlockTimestampLt,
				{
					Name: "filter_topic_1",
					In:   "query",
				}: params.FilterTopic1,
				{
					Name: "filter_topic_2",
					In:   "query",
				}: params.FilterTopic2,
				{
					Name: "filter_topic_3",
					In:   "query",
				}: params.FilterTopic3,
				{
					Name: "filter_topic_0",
					In:   "query",
				}: params.FilterTopic0,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EventsAddressSignatureGetParams
			Response = *EventsAddressSignatureGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEventsAddressSignatureGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EventsAddressSignatureGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EventsAddressSignatureGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeEventsAddressSignatureGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEventsGetRequest handles GET /events operation.
//
// Query events.
//
// GET /events
func (s *Server) handleEventsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EventsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EventsGetOperation,
			ID:   "",
		}
	)
	params, err := decodeEventsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EventsGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EventsGetOperation,
			OperationSummary: "Query events",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "sort_by",
					In:   "query",
				}: params.SortBy,
				{
					Name: "sort_order",
					In:   "query",
				}: params.SortOrder,
				{
					Name: "filter_block_timestamp",
					In:   "query",
				}: params.FilterBlockTimestamp,
				{
					Name: "filter_block_timestamp_gte",
					In:   "query",
				}: params.FilterBlockTimestampGte,
				{
					Name: "filter_block_timestamp_gt",
					In:   "query",
				}: params.FilterBlockTimestampGt,
				{
					Name: "filter_block_timestamp_lte",
					In:   "query",
				}: params.FilterBlockTimestampLte,
				{
					Name: "filter_block_timestamp_lt",
					In:   "query",
				}: params.FilterBlockTimestampLt,
				{
					Name: "filter_topic_1",
					In:   "query",
				}: params.FilterTopic1,
				{
					Name: "filter_topic_2",
					In:   "query",
				}: params.FilterTopic2,
				{
					Name: "filter_topic_3",
					In:   "query",
				}: params.FilterTopic3,
				{
					Name: "filter_topic_0",
					In:   "query",
				}: params.FilterTopic0,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EventsGetParams
			Response = *EventsGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEventsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EventsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EventsGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeEventsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStakingsGetRequest handles GET /stakings operation.
//
// Get stakings.
//
// GET /stakings
func (s *Server) handleStakingsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/stakings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), StakingsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code >= 100 && code < 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: StakingsGetOperation,
			ID:   "",
		}
	)
	params, err := decodeStakingsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *StakingsGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    StakingsGetOperation,
			OperationSummary: "Get stakings",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "pagination.key",
					In:   "query",
				}: params.PaginationKey,
				{
					Name: "pagination.limit",
					In:   "query",
				}: params.PaginationLimit,
				{
					Name: "reverse",
					In:   "query",
				}: params.Reverse,
				{
					Name: "filter_book_nft_in",
					In:   "query",
				}: params.FilterBookNftIn,
				{
					Name: "filter_account_in",
					In:   "query",
				}: params.FilterAccountIn,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = StakingsGetParams
			Response = *StakingsGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackStakingsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StakingsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.StakingsGet(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*ErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w, span); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w, span); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeStakingsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
